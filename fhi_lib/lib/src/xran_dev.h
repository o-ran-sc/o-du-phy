/******************************************************************************
*
*   Copyright (c) 2020 Intel.
*
*   Licensed under the Apache License, Version 2.0 (the "License");
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an "AS IS" BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.
*
*******************************************************************************/

/**
 * @brief XRAN layer O-DU|O-RU device context
 * @file xran_dev.h
 * @ingroup group_source_xran
 * @author Intel Corporation
 **/

#ifndef _XRAN_DEV_H_
#define _XRAN_DEV_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>
#include <unistd.h>
#include <sys/param.h>
#include <sys/queue.h>

#include <rte_common.h>
#include <rte_mbuf.h>
#include <rte_timer.h>
#include <rte_spinlock.h>

#include "xran_fh_o_du.h"
#include "xran_prach_cfg.h"
#include "xran_up_api.h"
#include "xran_cp_api.h"

#define DIV_ROUND_OFFSET(X,Y)       ( X/Y + ((X%Y)?1:0) )

#define MAX_NUM_OF_XRAN_CTX         (2)
#define MAX_CB_TIMER_CTX            (16*MAX_NUM_OF_XRAN_CTX)
#define XranIncrementCtx(ctx)       ((ctx >= (MAX_NUM_OF_XRAN_CTX-1)) ? 0 : (ctx+1))
#define XranDecrementCtx(ctx)                             ((ctx == 0) ? (MAX_NUM_OF_XRAN_CTX-1) : (ctx-1))

#define MAX_NUM_OF_DPDK_TIMERS      (32)
#define DpdkTimerIncrementCtx(ctx)  ((ctx >= (MAX_NUM_OF_DPDK_TIMERS-1)) ? 0 : (ctx+1))
#define DpdkTimerDecrementCtx(ctx)  ((ctx == 0) ? (MAX_NUM_OF_DPDK_TIMERS-1) : (ctx-1))

#define SUBFRAME_DURATION_US        (1000)

#define XRAN_MAX_LIST_USEDCORE      (64)

enum xran_job_type_id {
    XRAN_JOB_TYPE_OTA_CB   = 0,
    XRAN_JOB_TYPE_CP_DL    = 1,
    XRAN_JOB_TYPE_CP_UL    = 2,
    XRAN_JOB_TYPE_DEADLINE = 3,
    XRAN_JOB_TYPE_SYM_CB   = 4,
    XRAN_JOB_TYPE_MAX
};

enum xran_slot_cb_type_id {
    XRAN_SLOT_1_4_CB  = 0,
    XRAN_SLOT_HALF_CB = 1,
    XRAN_SLOT_3_4_CB  = 2,
    XRAN_SLOT_FULL_CB = 3,
    XRAN_SLOT_CB_TYPE_MAX
};

struct xran_timer_ctx {
    uint32_t    tti_to_process;
    uint32_t    ota_sym_idx;
    uint16_t    xran_sfn_at_sec_start;
    uint64_t    current_second;
};


#define XRAN_MAX_POOLS_PER_SECTOR_NR 12 /**< 2x(TX_OUT, RX_IN, PRACH_IN, SRS_IN, BFW_BUF, CSI-RS) with C-plane */

typedef struct sectorHandleInfo
{
    /**< Structure that contains the information to describe the
     * instance i.e service type, virtual function, package Id etc..*/
    uint16_t nIndex;
    uint16_t nXranPort;
    /* Unique ID of an handle shared between phy layer and library */
    /**< number of antennas supported per link*/
    uint32_t nBufferPoolIndex;
    /**< Buffer poolIndex*/
    struct rte_mempool * p_bufferPool[XRAN_MAX_POOLS_PER_SECTOR_NR];
    uint32_t bufferPoolElmSz[XRAN_MAX_POOLS_PER_SECTOR_NR];
    uint32_t bufferPoolNumElm[XRAN_MAX_POOLS_PER_SECTOR_NR];

}XranSectorHandleInfo, *PXranSectorHandleInfo;

typedef void (*XranSymCallbackFn)(struct rte_timer *tim, void* arg, void *p_dev_ctx, uint8_t mu);

#ifdef POLL_EBBU_OFFLOAD
typedef void (*XranSymCb)(struct rte_timer *tim, void* arg);
#endif

typedef int32_t (*tx_sym_gen_fn)(void* pHandle, uint8_t ctx_id, uint32_t tti, int32_t start_cc, int32_t num_cc, int32_t start_ant,  int32_t num_ant, uint32_t frame_id,
    uint32_t subframe_id, uint32_t slot_id, uint32_t sym_id, enum xran_comp_hdr_type compType, enum xran_pkt_dir direction,
    uint16_t xran_port_id, PSECTION_DB_TYPE p_sec_db, uint8_t mu, uint32_t tti_for_ring, uint32_t sym_id_for_ring, bool isVmu);

typedef int32_t (*tx_sym_fn)(void *arg, uint8_t mu);

struct cb_elem_entry{
    XranSymCallbackFn pSymCallback;
    void *pSymCallbackTag;
    void *p_dev_ctx;
    LIST_ENTRY(cb_elem_entry) pointers;
};

/* Callback function to send mbuf to the ring */
typedef int (*xran_ethdi_mbuf_send_fn)(struct rte_mbuf *mb, uint16_t ethertype, uint16_t vf_id);

/*
 * manage one cell's all Ethernet frames for one DL or UL LTE subframe
 */
typedef struct {
    /* -1-this subframe is not used in current frame format
         0-this subframe can be transmitted, i.e., data is ready
          1-this subframe is waiting transmission, i.e., data is not ready
         10 - DL transmission missing deadline. When FE needs this subframe data but bValid is still 1,
        set bValid to 10.
    */
    int32_t bValid ; // when UL rx, it is subframe index.
    int32_t nSegToBeGen;
    int32_t nSegGenerated; // how many date segment are generated by DL LTE processing or received from FE
                       // -1 means that DL packet to be transmitted is not ready in BS
    int32_t nSegTransferred; // number of data segments has been transmitted or received
    struct rte_mbuf *pData; // point to DPDK allocated memory pool
    struct xran_buffer_list sBufferList;
} BbuIoBufCtrlStruct;


#define XranIncrementJob(i)                  ((i >= (XRAN_SYM_JOB_SIZE-1)) ? 0 : (i+1))

#define XRAN_MAX_PKT_BURST_PER_SYM 96 /**< 16 layers with 6 sections each */
#define XRAN_MAX_PACKET_FRAG 9

#define MBUF_TABLE_SIZE  (2 * MAX(XRAN_MAX_PKT_BURST_PER_SYM, XRAN_MAX_PACKET_FRAG))

#define XRAN_IQ_FLOW_MAX 512 /**< Maximum flow IQ flows per XRAN port */

#define XRAN_MAX_MEM_IF_RING_SIZE 8*32


#define NBIOT_PRACH_NUM_SYM_GROUPS 4
#define NBIOT_NUM_SYMS_IN_ONE_GROUP 5
#define NBIOT_PRACH_F0_GROUP_DUR     1400 //us
#define NBIOT_PRACH_F1_GROUP_DUR     1600 //us


struct mbuf_table {
	uint16_t len;
	struct rte_mbuf *m_table[MBUF_TABLE_SIZE];
};

/** Symbols CB structure defining context of execution */
struct cb_user_per_sym_ctx {
    struct xran_timer_ctx user_cb_timer_ctx[MAX_CB_TIMER_CTX]; /**< DPDK timer context */ //TODOMIXED do we need to change this for mixed?
    xran_callback_sym_fn       symCb;        /**< call back for Symb event */
    void                      *symCbParam;  /**< parameters of call back function */
    struct xran_sense_of_time *symCbTimeInfo;  /**< Time related infomation to this CB */
    void  *p_dev;       /**< pointer back to corresponding Device context */
    int32_t status;       /** status of CB - free, used */
    int32_t symb_num_req; /**< requested Symb for CB */
    int32_t sym_diff; /**< delay/advance as measured against OTA "-" - delay(later OTA) "+" - advance (earlier OTA) */
    int32_t symb_num_ota; /**< corresponding "execution time" for Symb according to type of CB */
    int32_t cb_type_id;   /**< type of CB */

    /** DPDK timer specific variables */
    int32_t user_timer_put;  /**< put index (producer)*/
    int32_t user_timer_get;  /**< get index  (consumer)*/

    uint8_t mu; /* Numerology for this callback */
};

/** Shared data at the end of an external buffer for C-plane and U-plane*/
struct xran_shared_data_ucp_t {
    struct rte_mbuf_ext_shared_info sh_data[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_MAX_SECTIONS_PER_SLOT];
};

/** Shared data at the end of an external buffer for Beam forming weights */
struct xran_shared_data_bfw_t {
    struct rte_mbuf_ext_shared_info sh_data[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_MAX_SECTIONS_PER_SLOT];
};

/** Shared data at the end of an external buffer for SRS */
struct xran_shared_data_srs_t {
    struct rte_mbuf_ext_shared_info sh_data[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR];
};

/** Shared data at the end of an external buffer for CSIRS */
struct xran_shared_data_csi_t {
    struct rte_mbuf_ext_shared_info sh_data[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_CSIRS_PORTS];
};


/** Structure to hold the information for tracking the prb element processing across symbols.
 *  C-Plane processing for every slot is spread equally across symbols that fall within allowed window.
 *  This structure is used to keep track of processing that is done.
 */
struct xran_prb_elm_proc_info_t {
    uint16_t  nPrbElmPerSym;    /**< Number of prb elements to be processed per symbol */
    uint16_t  nPrbElmProcessed; /**< Holds the number of PrbElms Processed in a given symbol time by xran. */
    uint8_t   numSymsRemaining; /**< Number of symbols for DL CP transmission remaining in this slot */
};

typedef struct nbiot_prach_xmit_sfId_sym_pair
{
    uint8_t sf;
    uint8_t sym;
}nbiot_prach_xmit_sfId_sym_pair;


typedef struct xran_device_per_mu_fields
{
    uint8_t mu;         /* Numerology; */
    void    *p_dev_ctx; /* Back pointer to device context */
    uint8_t eaxcOffset; /* Antenna Offset for this mu, used for NBIOT. TODO: THis could go beyond 256. Should be uint16_t */

    uint32_t enablePrach;
    struct xran_prach_cp_config  PrachCPConfig;
    struct xran_prach_cp_config  PrachCPConfigLTE;

    uint8_t numSetBFWs_arr[XRAN_MAX_SECTIONS_PER_SLOT];
    /* This should point to application memory and application is expected to update every tti for given numerology.
     * Xran will access cplane and uplane shared buffers for active numerologies and send the packets out for that tti.
     */
    BbuIoBufCtrlStruct sFrontHaulTxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
    BbuIoBufCtrlStruct sFrontHaulTxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
    BbuIoBufCtrlStruct sFrontHaulRxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
    BbuIoBufCtrlStruct sFrontHaulRxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
    BbuIoBufCtrlStruct sFHPrachRxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
    BbuIoBufCtrlStruct sFHPrachRxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];

    BbuIoBufCtrlStruct sFHSrsRxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR];
    BbuIoBufCtrlStruct sFHSrsRxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANT_ARRAY_ELM_NR];

    BbuIoBufCtrlStruct sFHCsirsTxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_CSIRS_PORTS];
    BbuIoBufCtrlStruct sFHCsirsTxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_CSIRS_PORTS];

    BbuIoBufCtrlStruct sFHCpRxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
    BbuIoBufCtrlStruct sFHCpTxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];

    /* buffers lists */
    struct rte_mbuf *to_free_mbuf[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR][XRAN_NUM_OF_SYMBOL_PER_SLOT][XRAN_MAX_SECTIONS_PER_SLOT];

    LIST_HEAD(sym_cb_elem_list, cb_elem_entry) sym_cb_list_head[XRAN_NUM_OF_SYMBOL_PER_SLOT];
    int32_t sym_up; /**< when we start sym 0 of up with respect to OTA time as measured in symbols */
    int32_t sym_up_ul_ub;
    int32_t sym_up_ul_lb;

    int32_t ruRxSymUpMin;
    int32_t ruRxSymUpMax;

    struct xran_timer_ctx timer_ctx[MAX_NUM_OF_XRAN_CTX];
    struct xran_timer_ctx cb_timer_ctx[MAX_CB_TIMER_CTX];

    int timer_put;
    int timer_get;
    /* per numerology per symbol callback context */
    struct cb_user_per_sym_ctx symCbCtx[XRAN_NUM_OF_SYMBOL_PER_SLOT][XRAN_CB_SYM_MAX];

    uint8_t dlCpTxSym; /* Symbol within the slot where dl cplane packets should be transmitted */
    uint8_t ulCpTxSym; /* Symbol within the slot where ul cplane packets should be transmitted */

    /* Keeps track of how many sections are processed while parsing C-plan packet */
    uint8_t sectiondb_elm[XRAN_MAX_SECTIONDB_CTX][XRAN_DIR_MAX][XRAN_COMPONENT_CARRIERS_MAX][XRAN_MAX_ANTENNA_NR * 2 + XRAN_MAX_ANT_ARRAY_ELM_NR];

    uint8_t ulCpSlotOffset; /* Indicates the tti offset to use while sending UL Cp packets.
                               (Decided based on T1a_max_cp_ul)
                               When Current OTA is N:
                               For N+1 tti: ulCpSlotOffset=0
                               For N+2 tti: ulCpSlotOffset=1  */
    uint8_t adv_tx_factor;   /*Symbol division factor by which transmission of pkt to be done early */

    uint8_t deadline_slot_advance[XRAN_SLOT_CB_TYPE_MAX];   /* if CB for deadline should be in next slot but reflect current slot */

    nbiot_prach_xmit_sfId_sym_pair sfSymToXmitPrach[NBIOT_PRACH_NUM_SYM_GROUPS];
}xran_device_per_mu_fields;

typedef struct slot_map
{
    /* should be indexed using sectionId. Value indicates the numerology that it belongs to */
    uint16_t sectIdMu[XRAN_MAX_SECTIONS_PER_SLOT]; /* Possible array index: 0-XRAN_MAX_SECTIONS_PER_SLOT;
                                                     Possible values: 0-XRAN_MAX_NUM_MU */
}slot_map;

/* We need to maintain a mapping of sectionId to Numerology since ORAN Uplane headers don't have sectionType field
 * and hence can't differentiate between numerologyes.
 * This structure is used to maintain mapping of sectionIds to numerology in case of mixed numerology being used.
 * This should be populated to UL cplane logic while assigning the sectionIds and used by UL Uplane logic to
 * identify the numerology that the given sectionId belongs to.
 */
typedef struct xran_sec_id_mu_map
{
    slot_map    slotMap[SUBFRAME_DURATION_US/2^XRAN_MAX_NUM_MU]; /* possible slot index */
    uint8_t     frameId;    /* 0-256 */
    uint8_t     sfId:4;     /* 0-9 */
    uint8_t     entryActive:1; /* 0/1 */
    uint8_t     reserved:3;
}xran_sec_id_mu_map;


struct xran_cc_config
{
    int16_t  ccId;      /* Carrier component ID */

    enum xran_category ruCat;           /**< mode: Catergory A or Category B */ /* cannot be different within RU?? */
    enum xran_ran_tech ranTech;         /**< 5GNR or LTE */
    enum xran_comp_hdr_type cmpHdrType; /**< dynamic or static udCompHdr handling */

    uint8_t  iqWidth;                   /**< IQ bit width */
    uint8_t  compMeth;                  /**< Compression method */
    uint8_t  iqWidth_PRACH;             /**< IQ bit width for PRACH */
    uint8_t  compMeth_PRACH;            /**< Compression method for PRACH */
    uint8_t  fftSize[XRAN_MAX_NUM_MU];  /**< FFT Size */

    uint32_t neAxc;                 /**< number of eAxc supported on this CC */
    uint32_t neAxcUl;               /**< number of eAxc supported on this CC for UL direction */
    uint32_t nAntElmTRx;            /**< Number of antenna elements for TX and RX */
    uint32_t nDLAbsFrePointA;       /**< Abs Freq Point A of the Carrier Center Frequency for in KHz Value: 450000->52600000 */
    uint32_t nULAbsFrePointA;       /**< Abs Freq Point A of the Carrier Center Frequency for in KHz Value: 450000->52600000 */
    uint32_t nDLCenterFreqARFCN;    /**< Center frequency for DL in MHz */
    uint32_t nULCenterFreqARFCN;    /**< Center frequency for UL in MHz */

    uint32_t nDLBandwidth;    /**< Carrier bandwidth for in MHz. Value: 5->400 */
    uint32_t nULBandwidth;    /**< Carrier bandwidth for in MHz. Value: 5->400 */
    int32_t  freqOffset;

    uint16_t nDLFftSize;  /**< DL FFT size */
    uint16_t nULFftSize;  /**< UL FFT size */
    uint16_t nDLRBs;      /**< DL PRB  */
    uint16_t nULRBs;      /**< UL PRB  */

    uint8_t  nNumerology;           /**< Numerology, determine sub carrier spacing, Value: 0->4
                                       0: 15khz,  1: 30khz,  2: 60khz
                                       3: 120khz, 4: 240khz. */
    uint8_t  prachEnable;    /**<  enable PRACH   */
    //uint8_t prachConfigIndex;/**< TS36.211 - Table 5.7.1-2 : PRACH Configuration Index */
    //uint8_t prachConfigIndexLTE;/**< PRACH Configuration Index for LTE in dss case*/
    uint8_t  enableCP;              /**<  enable C-plane */
    uint8_t  srsEnable;             /**<  enable SRS (Cat B specific) */
    uint8_t  srsEnableCp;           /**<  enable SRS Cp(Cat B specific) */
    uint8_t  SrsDelaySym;           /**<  enable SRS Cp(Cat B specific) */
    uint8_t  puschMaskEnable;       /**< enable pusch mask> */
    uint8_t  puschMaskSlot;         /**< specific which slot pusch channel masked> */
    uint8_t  csirsEnable;           /**<  enable CSI-RS (Cat B specific) */
    int32_t  DynamicSectionEna;     /**<  enable dynamic C-Plane section allocation */

    struct xran_prach_config prach_pri;     /* PRACH configuration for primary (in case of DSS) */
    struct xran_prach_config prach_2nd;     /* PRACH configuration for secondary (in case of DSS) */
    struct xran_frame_config frame_conf;    /**< frame config */
    struct xran_srs_config srs_conf;        /**< SRS specific configurations for FH */
    struct xran_csirs_config csirs_conf;    /**< CSI-RS specific configurations for FH */

    uint16_t maxSectionsPerSlot;    /**< M-Plane settings for section */
    uint16_t maxSectionsPerSymbol;  /**< M-Plane settings for section */
    int32_t  RunSlotPrbMapBySymbolEnable; /**< enable prb mapping by symbol with multisection*/

    uint8_t numSymsForDlCP; /**< number of symbols for DL CP transmission */
    int prach_start_symbol;
    int prach_last_symbol;

    uint8_t dssEnable;  /**< enable DSS (extension-9) */
    uint8_t dssPeriod;  /**< DSS pattern period for LTE/NR */
    uint8_t technology[XRAN_MAX_DSS_PERIODICITY];   /**< technology array represents slot is LTE(0)/NR(1) */
    xran_active_numerologies_per_tti *activeMUs;    /**< Should be set per slot to true or false indicating whether
                                                         this numerology is active in this slot */

    nbiot_ul_scs nbIotUlScs;     /**< Applicable only for NB-IOT (mu=4). NBIOT supports asymmetric SCS usage in
                                      downlink and uplink directions. xran library will use this parameter to derive
                                      slot-duration for UL NB-IOT:
                                      XRAN_NBIOT_UL_SCS_15: slot-duration=1ms
                                      XRAN_NBIOT_UL_SCS_3_75: slot-duration=2ms */
};

/* Support SSB running on a virtual numerology
   Virtual numerology - Timing thread uses xran_device_per_mu_fields numerology (mu)
   to calculate the sym, sub-frame, slot id. sym, subframe, slot id for virtual numerology
   will be derived from timer mu. */
typedef struct xran_ssb_info_s {

    uint8_t  ruPortId_offset;
    uint8_t  ssbMu;
    uint16_t freqOffset;

    BbuIoBufCtrlStruct sFhSsbTxPrbMapBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
    BbuIoBufCtrlStruct sFHSsbTxBbuIoBufCtrl[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];

} xran_ssb_info;

typedef struct xran_device_virtual_mu_fields_s {
    xran_ssb_info ssbInfo;
} xran_device_virtual_mu_fields;

typedef struct /* TO DO __rte_cache_aligned*/ xran_device_ctx
{
    uint8_t sector_id;
    uint8_t xran_port_id;
    struct xran_eaxcid_config    eAxc_id_cfg;
    struct xran_fh_config        fh_cfg;
    uint32_t enableCP;
    uint8_t  dlCpProcBurst;

    uint32_t mtu;
    uint16_t numRxq;            /**< number of RX queues per VF */
    uint16_t totalBfWeights;    /**< The total number of beamforming weights for RU mode (to parse extension) */

    int32_t  DynamicSectionEna;
    int32_t  RunSlotPrbMapBySymbolEnable;
    uint32_t enableSrs;
    uint16_t enableSrsCp;
    uint16_t nSrsDelaySym;
    uint8_t  puschMaskEnable;
    uint8_t  puschMaskSlot;
    uint8_t  csirsEnable;
    struct xran_srs_config srs_cfg; /** configuration of SRS */
    struct xran_csirs_config csirs_cfg; /** configuration of CSI-RS */

    rte_spinlock_t spinLock;/* spinlock for active_CC and active_nCC */
    uint32_t active_nCC;    /* total number of CCs in activate state */
    uint64_t active_CC;     /* Each bit will be 1 when active (xran_activate_cc),
                             * each bit corresponds to the index of CC */
    uint32_t cfged_nCC;     /* number of Component carriers configured on this RU */
    int16_t  cfged_CCId[XRAN_MAX_SECTOR_NR];   /* configured cc id will be stored,
                                                     * -1 means not configured or deleted */
    struct xran_cc_config ccCfg[XRAN_MAX_SECTOR_NR];
    /* This should point to application memory and application is expected to update every tti for given numerology.
     * Xran will access cplane and uplane shared buffers for active numerologies and send the packets out for that tti.
     */
    xran_active_numerologies_per_tti *perSlotMuActiveStatus;
    xran_device_per_mu_fields* perMu;

    xran_device_virtual_mu_fields vMuInfo;

    xran_transport_callback_fn pCallback[XRAN_MAX_SECTOR_NR];
    void *pCallbackTag[XRAN_MAX_SECTOR_NR];

    xran_transport_callback_fn pPrachCallback[XRAN_MAX_SECTOR_NR];
    void *pPrachCallbackTag[XRAN_MAX_SECTOR_NR];

    xran_transport_callback_fn pSrsCallback[XRAN_MAX_SECTOR_NR];
    void *pSrsCallbackTag[XRAN_MAX_SECTOR_NR];

    xran_transport_callback_fn pCsirsCallback[XRAN_MAX_SECTOR_NR];
    void *pCsirsCallbackTag[XRAN_MAX_SECTOR_NR];

    int xran2phy_mem_ready;

    /*Enable when implemented:
     * int rx_packet_symb_tracker[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_NUM_OF_SYMBOL_PER_SLOT];
    int rx_packet_prach_tracker[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_NUM_OF_SYMBOL_PER_SLOT];
    int rx_packet_callback_tracker[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR];
    int rx_packet_prach_callback_tracker[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR];*/

    int prach_start_symbol[XRAN_MAX_SECTOR_NR];
    int prach_last_symbol[XRAN_MAX_SECTOR_NR];


    struct rte_mempool *direct_pool;
    struct rte_mempool *indirect_pool;

    struct xran_common_counters fh_counters;

    xran_ethdi_mbuf_send_fn send_cpmbuf2ring;   /**< callback to send mbufs of C-Plane packets to the VF ring */
    xran_ethdi_mbuf_send_fn send_upmbuf2ring;   /**< callback to send mbufs of U-Plane packets to the VF ring */

    /*Added different timer handles for numerologies
     *in case the callback occurs for both at the same time*/
    struct rte_timer dpdk_timer[MAX_NUM_OF_DPDK_TIMERS];

    uint16_t map2vf[2][XRAN_COMPONENT_CARRIERS_MAX][XRAN_MAX_ANTENNA_NR*2 + XRAN_MAX_ANT_ARRAY_ELM_NR][XRAN_VF_MAX];

    int32_t ctx;

    bool use_tx_sym_gen_func; /*Used for RU */

    tx_sym_gen_fn tx_sym_gen_func;
    tx_sym_fn tx_sym_func;

    int32_t job2wrk_id[XRAN_JOB_TYPE_MAX]; /** mapping of HI prio Job to worker core */

    /* share_data, cp_share_data, bfw_share_data, srs_share_data: Sets callback to call when an mbuf is freed. Nothing is done in this today. If specific
     * processing is added later, this may have to move to perMu structure
     */
    struct xran_shared_data_ucp_t share_data;
    struct xran_shared_data_ucp_t cp_share_data;
    struct xran_shared_data_bfw_t bfw_share_data;
    struct xran_shared_data_srs_t srs_share_data;
    struct xran_shared_data_csi_t csirs_share_data;

    struct rte_flow *p_iq_flow[XRAN_IQ_FLOW_MAX];
    uint32_t iq_flow_cnt;  /**< number of IQ flows configured */

    uint8_t ndm_srs_scheduled;      /* set if SRS has been scheduled */
    uint8_t ndm_srs_schedperiod;    /* SRS slot within TDD period */
    uint32_t ndm_srs_txtti;         /* first slot for transmit SRS within TDD period */
    uint32_t ndm_srs_tti;           /* original SRS slot */

    uint8_t numSymsForDlCP; /**< number of symbols for DL CP transmission */
    struct xran_prb_elm_proc_info_t prbElmProcInfo[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_ANTENNA_NR];
    struct xran_prb_elm_proc_info_t prbElmProcCSIInfo[XRAN_N_FE_BUF_LEN][XRAN_MAX_SECTOR_NR][XRAN_MAX_CSIRS_PORTS];

    uint8_t dssEnable;      /**< enable DSS (extension-9) */
    uint8_t dssPeriod;      /**< DSS pattern period for LTE/NR */
    uint8_t technology[XRAN_MAX_DSS_PERIODICITY];   /**< technology array represents slot is LTE(0)/NR(1) */

    /* For OWD */
    int8_t *p_o_du_addr;    /* TODO: need to revisit */
    int8_t *p_o_ru_addr;    /* TODO: need to revisit */
    struct xran_ecpri_del_meas_cmn eowd_cmn[2];
    struct xran_ecpri_del_meas_port eowd_port[2][XRAN_VF_MAX];

#if 0 /* dynamic sectId <--> mu mapping */
    /* Structure to hold the sectionId to numerology mapping for a given {frameId, subframeId, slotId}
     * for MixedMu Transmission/Reception.
     * If frameId and subframeId in a given packet matches to the pair in the structure Object,
     * the slotId and sectionId should be used as indices to store the numerology for a given sectionId.
     * It is assumed that only 2 different values of {frameId, sfId} tuple are sufficient.
     *
     * This is updated ODU UL CP Tx logic and used by ODU UL UP Rx logic */
    xran_sec_id_mu_map sectIdMUmap[2];
    uint8_t sectIdMUmapWriteIndex; /* points to the sectIdMUmap entry that should be updated for a new packet */
#endif
} xran_device_ctx_t;


struct xran_system_config
{
    char *filePrefix;           /* DPDK prefix */
    struct xran_io_cfg io_cfg;  /* DPDK IO for XRAN */
    int64_t  offset_sec;
    int64_t  offset_nsec;    //offset to GPS time calculated based on alpha and beta

    uint32_t cores_Num;         /* the number of total used cores */
    uint32_t cores_List[XRAN_MAX_LIST_USEDCORE]; /* the list of used core id */

    uint32_t numRUs;        /* Number of O-RUs connected to this instantiation of ORAN FH layer */
    rte_spinlock_t spinLock;/* spinlock for active_RU and active_nRU */
    uint32_t active_nRU;    /* Total number of RUs in activate state */
    uint32_t active_RU;     /* Each bit will be 1 when active (xran_open),
                             * each bit corresponds to the index of device context */
    rte_atomic32_t nStart;
    int32_t  xran2phy_mem_ready;

    uint32_t ttiBaseMu;     /* Numerology for the period of TTI indication */

    /* For debug purposes */
    int32_t  debugStop;         /*  enable auto stop */
    int32_t  debugStopCount;    /*  enable auto stop after number of Tx packets */
    int32_t  mlogEnable;        /* whether or not enable mlog during runtime 0:disable 1:enable */

    uint32_t rru_workaround;    /*  rru workaround flag */
    phy_encoder_poll_fn bbdevEnc;   /* call back function to poll BBDev encoder */
    phy_decoder_poll_fn bbdevDec;   /* call back function to poll BBDev decoder */
    phy_srs_fft_poll_fn bbdevSrsFft; /** Callback functions to poll BBdev SRS FFT */
    phy_prach_ifft_poll_fn bbdevPrachIfft; /** Callback functions to poll BBdev PRACH IFFT */

    xran_callback_oam_notify_fn oam_notify_cb;

    uint32_t logLevel;  /**< configuration of log level */
};

extern struct xran_device_ctx *g_xran_dev_ctx[XRAN_PORTS_NUM];

#define XRAN_GET_DEV_CTX g_xran_dev_ctx[0]
#define XRAN_GET_OXU_PORT_ID(pDevCtx) (pDevCtx)->xran_port_id

struct xran_eaxcid_config *xran_get_conf_eAxC(uint8_t oxu_port_id);
uint8_t xran_get_conf_prach_scs(void *pHandle, uint8_t mu);
uint8_t xran_get_conf_highest_numerology(void *pHandle);
uint8_t xran_get_conf_fftsize(void *pHandle, uint8_t mu);
uint8_t xran_get_conf_numerology(void *pHandle);
uint8_t xran_get_conf_iqwidth_prach(void *pHandle);
uint8_t xran_get_conf_compmethod_prach(void *pHandle);

uint8_t xran_get_conf_iqwidth(void *pHandle);
uint8_t xran_get_conf_compmethod(void *pHandle);
uint8_t xran_get_conf_num_bfweights(void *pHandle);
uint8_t xran_get_num_cc(void *pHandle);
uint8_t xran_get_num_eAxc(void *pHandle);
uint8_t xran_get_num_eAxcUl(void *pHandle);
uint8_t xran_get_num_ant_elm(void *pHandle);
enum xran_category xran_get_ru_category(void *pHandle);
uint16_t xran_get_beamid(void *pHandle, uint8_t dir, uint8_t cc_id, uint8_t ant_id, uint8_t slot_id);

int32_t xran_dev_create_ctx(uint32_t xran_ports_num);
int32_t xran_dev_destroy_ctx();
struct xran_device_ctx *xran_dev_get_ctx_by_id(uint32_t xran_port_id);
struct xran_device_ctx **xran_dev_get_ctx_addr(void);

struct cb_elem_entry *xran_create_cb(XranSymCallbackFn cb_fn, void *cb_data, void* p_dev_ctx);
int32_t xran_destroy_cb(struct cb_elem_entry * cb_elm);

uint16_t xran_map_ecpriRtcid_to_vf(struct xran_device_ctx *p_dev_ctx, int32_t dir, int32_t cc_id, int32_t ru_port_id);
uint16_t xran_map_ecpriPcid_to_vf(struct xran_device_ctx *p_dev_ctx,  int32_t dir, int32_t cc_id, int32_t ru_port_id);

uint16_t xran_set_map_ecpriRtcid_to_vf(struct xran_device_ctx *p_dev_ctx, int32_t dir, int32_t cc_id, int32_t ru_port_id, uint16_t vf_id);
uint16_t xran_set_map_ecpriPcid_to_vf(struct xran_device_ctx *p_dev_ctx,  int32_t dir, int32_t cc_id, int32_t ru_port_id, uint16_t vf_id);

int32_t xran_init_vfs_mapping(void *pHandle);
int32_t xran_init_vf_rxq_to_pcid_mapping(void *pHandle);

int xran_dev_add_usedcore(int core_id);
int xran_dev_get_num_usedcores(void);
uint32_t *xran_dev_get_list_usedcores(void);
int xran_dev_init_num_usedcores(void);

static inline int8_t xran_dev_ctx_get_port_id(void * handle)
{
    struct xran_device_ctx * p_dev_ctx  = (struct xran_device_ctx *)handle;
    if(p_dev_ctx)
        return (int8_t)p_dev_ctx->xran_port_id;
    else
        return -1;
};


extern struct xran_system_config gSysCfg;
inline struct xran_system_config *xran_get_systemcfg(void)
{
    return(&gSysCfg);
}
inline int xran_get_syscfg_totalnumru(void)
{
    return(xran_get_systemcfg()->numRUs);
}
inline struct xran_io_cfg *xran_get_sysiocfg(void)
{
    return(&gSysCfg.io_cfg);
}
inline int xran_get_syscfg_appmode(void)
{
    return(xran_get_sysiocfg()->id);
}
inline int xran_get_syscfg_bbuoffload(void)
{
    return(xran_get_sysiocfg()->bbu_offload);
}
inline int xran_get_syscfg_iosleep(void)
{
    return(xran_get_sysiocfg()->io_sleep);
}

inline int32_t xran_isactive_ru(void *pHandle)
{
    uint32_t ru_id;

    if(unlikely(pHandle == NULL))
        return(0);

    ru_id = ((struct xran_device_ctx *)pHandle)->xran_port_id;
    if(likely(ru_id < XRAN_PORTS_NUM))
        return(xran_get_systemcfg()->active_RU & (1 << ru_id));
    else
        return(0);
}
inline int32_t xran_isactive_ru_byid(uint32_t ru_id)
{
    if(unlikely(ru_id >= XRAN_PORTS_NUM))
        return(0);
    else
        return(xran_get_systemcfg()->active_RU & (1 << ru_id));
}
inline int32_t xran_set_active_ru(uint32_t ru_id)
{
    if(unlikely(ru_id >= XRAN_PORTS_NUM))
        return(-1);

    struct xran_system_config *sysCfg = xran_get_systemcfg();
    if(sysCfg)
    {
        if(!xran_isactive_ru_byid(ru_id))
        {
            rte_spinlock_lock(&sysCfg->spinLock);
            sysCfg->active_RU |= 1 << ru_id;
            sysCfg->active_nRU++;
            rte_spinlock_unlock(&sysCfg->spinLock);
        }
    }
    return(0);
}
inline int32_t xran_set_deactive_ru(uint32_t ru_id)
{
    if(unlikely(ru_id >= XRAN_PORTS_NUM))
        return(-1);

    struct xran_system_config *sysCfg = xran_get_systemcfg();
    if(sysCfg)
    {
        if(xran_isactive_ru_byid(ru_id))
        {
            rte_spinlock_lock(&sysCfg->spinLock);
            sysCfg->active_RU &= ~(1 << ru_id);
            sysCfg->active_nRU--;
            rte_spinlock_unlock(&sysCfg->spinLock);
        }
    }
    return(0);
}

inline int32_t xran_isactive_cc(void *pHandle, uint32_t cc_id)
{
    struct xran_device_ctx *pDevCtx;

    if(likely(cc_id < XRAN_MAX_SECTOR_NR && pHandle != NULL))
    {
        pDevCtx = (struct xran_device_ctx *)pHandle;
        return(pDevCtx->active_CC & (1L << cc_id));
    }
    else
        return(0);
}
inline int32_t xran_get_numactiveccs_ru(void *pHandle)
{
    struct xran_device_ctx *pDevCtx;

    if(likely(pHandle != NULL))
    {
        pDevCtx = (struct xran_device_ctx *)pHandle;
        return(pDevCtx->active_nCC);
    }
    else
        return(0);
}

#ifdef __cplusplus
}
#endif

#endif

